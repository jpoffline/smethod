\documentclass[amsmath,amssymb,12pt, eqsecnum]{revtex4}
\usepackage{graphicx, amsmath, amsmath, amssymb}
\usepackage[breaklinks, colorlinks, citecolor=blue]{hyperref}
\newcommand\codeRed[1]{\textcolor[rgb]{1,0,0}{{\tt #1}}}
\newcommand\codeBlue[1]{\textcolor[rgb]{0,0,1}{{\tt #1}}}
\newcommand{\michi}[1]{\textcolor{blue}{{\bf M}: #1}\\}
\newcommand{\jonathan}[1]{\textcolor{cyan}{{\bf J}: #1}\\}
\input{defs}
\linespread{1}

\begin{document}
\title{Numerics}
\author{Jonathan A. Pearson}
\email{jonathan.pearson@durham.ac.uk}
\affiliation{Centre for Particle Theory, Department of Mathematical Sciences, Durham University, South Road, Durham, DH1 3LE, U.K.}
\date{\today}
\begin{abstract}
 
\end{abstract}

\maketitle
\tableofcontents
\section{Introduction}

These notes contain descriptions of the numerics and algorithms.

The idea is to construct a code to evolve
\bea
\square\Phi + m^2\Phi =0,
\eea
where
\bea
\square\Phi =g^{\mu\nu} \nabla_{\mu}\nabla_{\nu}\Phi  ,
\eea
in which the metric is
\bea
\label{eq:sec:metric-conf}
g_{\mu\nu}\dd x^{\mu} \dd x^{\nu} = a^2(\tau)\bigg[ -e^{2V}\dd\tau^2 + e^{-2V}\dd x_i\dd x^i \bigg],
\eea
and $V$ solves the Poisson equation,
\bea
\nabla^2 V =   {4\pi G}{ }a^2\qsubrm{\rho}{dust} \bigg( |\Phi a^{3/2}|^2 -1\bigg),\qquad \qsubrm{\rho}{dust} = \qsubrm{\bar{\rho}}{dust}/a^3
\eea
\textcolor[rgb]{1,0,0}{{ There seems to a bug in the relativistic Widrow paper \cite{Widrow:1996eq}}}: $\Phi^* \Phi$ decays like $a^{-3}$ on an expanding space. Therefore Eq.\,(15)  in\cite{Widrow:1996eq} should read $\mathcal{F} = \sqrt{-g} | \langle e(x,p) | \Phi\rangle |^2$. If the extra factor $\sqrt{-g}$ is not added, then the energy momentum tensor 
\begin{equation}
T_{\mu \nu}(x^\alpha) = \int  \frac{dp_1 dp_2 dp_3}{\sqrt{-g} p^0(p_j)} p_\mu p_\nu f(p_{i},x^\alpha)
\end{equation}
won't come out correctly (and therefore $\mathcal{F}$ wouldn't fulfil the Vlasov equation.) [I need to check that that this is true]

On flat space, the scalar fields equation of motion is
\bea
\ddot{\Phi} - \nabla^2\Phi = - \frac{\dd V}{\dd\Phi}.
\eea
\subsection{Play}
Assuming that $V = V(\rbm{x})$ only, the scalar field equation of motion, $\square\Phi =\partial_\mu ( \sqrt{-g} g^{\mu \nu} \partial_{\nu})/ \sqrt{-g}= - U'$, expanded to first order in $V$, as defined by (\ref{eq:sec:metric-conf}),  is
\bea
  e^{-2    V {}} (\Phi_{,\tau \tau} +2 \hct \Phi_{,\tau})  =e^{2    V {}}\partial_i\partial_i \Phi  -a^2\frac{\dd U}{\dd\Phi}.
\eea
When $V$ is small,
\bea
\Phi_{,\tau \tau} +2 \hct \Phi_{,\tau} = (1+4V)\partial_i\partial_i\Phi -a^2 (1+2V)\frac{\dd U}{\dd\Phi},
\eea
where $\hct = a H$. This is most likely the equation we want to evolve. We might also want to go to scale factor time $a$ via $d \tau = (a^2 H)^{-1} da$ or to superconformal time $\eta$ via $d \tau = a d \eta$. We simply need to replace $\partial_\tau = a^2 H \partial_a$ or $\partial_\tau = a^{-1} \partial_\eta$ in the KG equation. In scale factor time
\bea
a^4 H^2 \Phi_{,aa} +(4 a^3 H^2+ a^4 H H_{,a}  ) \Phi_{,a} = (1+4V)\partial_i\partial_i\Phi -a^2 (1+2V)\frac{\dd U}{\dd\Phi},
\eea
or superconformal time
\bea
a^{-2} \Phi_{,\eta \eta} + H \Phi_{,\eta} = (1+4V)\partial_i\partial_i\Phi -a^2 (1+2V)\frac{\dd U}{\dd\Phi}\,.
\eea
None of these times seem to be useful in the KG case (but see Schr\"odinger below). 

To get to the Schrodinger point of view, define $\Phi = \phi e^{-\ci m t}$,  where $t$ is cosmic time and plug
\bea
\Phi_{,t} = (\phi_{,t} - \ci m \phi) e^{-\ci mt},\qquad \Phi_{,tt} = (\phi_{,tt} - 2 \ci m \phi_{,t} - m^2\phi) e^{-\ci mt},
\eea
into 
\bea
 \Phi_{,t t} + 3 H \Phi_{,t} = (1+4V)a^{-2}\partial_i\partial_i\Phi - (1+2V)\frac{\dd U}{\dd\Phi}\,.
\eea
and obtain
\bea
\phi_{,tt} +(3 H   -  2 \ci m) \phi_{,t}- m\phi(m  +3\ci H   )   =(1+4    V {})a^{-2}\partial_i\partial_i \phi  -(1+2    V {})\frac{\dd U}{\dd\phi^*}.
\eea
We now insert $\dd U/\dd\phi^* = m^2 \phi$ and assume that $H/m = \mathcal{O}(\epsilon)$,  $V \phi = \partial_t \phi/m = \nabla^2 \phi/m^2 = \phi \mathcal{O}(\epsilon)$ and $\partial_t^2 \phi/m^2=\phi \mathcal{O}(\epsilon^2) $ and $\epsilon \ll1$, arriving at 
\bea
\ci \hbar (\partial_t \phi + \frac{3}{2} H \phi) = - \frac{\hbar^2}{2a^2m} \nabla^2\phi + mV(\rbm{x}) \phi,
\eea
Or introducing $\psi = a^{3/2} \phi$,
(the factor $a^{3/2}$ removes the Hubble friction in the Schr\"odinger equation and allows to write $\mathcal{F} = | \langle e(x,p) | \psi\rangle |^2$ without the extra factor $ \sqrt{-g}$) 
\bea
\ci \hbar \partial_t \psi = - \frac{\hbar^2}{2a^2m} \nabla^2\psi + mV(\rbm{x}) \psi,
\eea
and breaking up the complex degrees of freedom via $\psi = \psi_1 + \ci \psi_2$, one obtains the  set of equations for  two coupled real scalar fields,
\bea
\hbar \partial_t\psi_1 &=& - \frac{\hbar^2}{2a^2m}\nabla^2\psi_2 + m V(\rbm{x})\psi_2,\\
\hbar \partial_t\psi_2 &=& \frac{\hbar^2}{2a^2m} \nabla^2\psi_1 - mV(\rbm{x})\psi_1.
\eea

Note that the Hubble friction term can be removed also from the KG equation by defining $\bar \Phi = \Phi a^{3/2}$, plugging $\bar \Phi$ into the KG equation we obtain 
\bea
 \bar \Phi_{,t t} - \frac{3}{2} (H_{,t}+\frac{3}{2}  H^2) \bar \Phi = (1+4V)a^{-2}\partial_i\partial_i \bar\Phi - (1+2V) m^2 \bar \Phi\,.
\eea
(The advantage is again that $\mathcal{F} = | \langle e(x,p) | \bar \Phi \rangle |^2$ and that the numerical values of $\bar \Phi$ should lie in smaller range than $\Phi$.)
The following equation might be a good approximation since $H/m = \mathcal{O}(\epsilon)$ and $V=  \mathcal{O}(\epsilon) $
\bea
 \bar \Phi_{,t t}  = a^{-2}\partial_i\partial_i \bar\Phi - (1+2V) m^2 \bar \Phi\,.
\eea
Note that the $V$ in $(1+2V) m^2$ cannot be dropped because $\Phi_{,t t}$ will cancel the 1. \michi{Without knowing that it would seem strange that the little $V$ should have any impact on the dynamics of $\bar \Phi$}
\subsection{Literature review}
\cite{1993ApJ...416L..71W}, \cite{Widrow:1996eq}, \cite{Uhlemann:2014npa} 
\subsection{Discretization}
Space will be discretized onto a lattice; the spacing between lattice sites is $h$.  A quantity, $Q$, in 2D is discretized so that it lives on the lattice; $Q(x,y) \rightarrow Q_{i,j}$. 


\section{Equations of motion}
Here we summarize the equations of motion which are being solved. We also write the equations in the precise form that is implemented in the code; that is, in their dimensionless forms.
\subsection{Klein Gordon-Poisson}
 
\subsection{Schrodinger-Poisson}
The dynamical equation of motion for the complex scalar $\psi$ is
\bea
\ci \hbar \partial_t \psi = - \frac{\hbar^2}{2a^2m} \nabla^2\psi + mV(\rbm{x}) \psi,
\eea
where $V$ solves the Poisson equation,
\bea
\nabla^2 V =   {4\pi G}{ }a^2\qsubrm{\rho}{dust} \big( |\psi|^2 -1\big),\qquad \qsubrm{\rho}{dust} = \qsubrm{\bar{\rho}}{dust}/a^3.
\eea
Write as
\bea
\nabla^2V = \frac{3H_0^2}{2a}(|\psi|^2 - 1)
\eea
Breaking up the complex degrees of freedom via $\psi = \psi_1 + \ci \psi_2$, one obtains the  set of equations for  two coupled real scalar fields,
\bea
\hbar \partial_t\psi_1 &=& - \frac{\hbar^2}{2a^2m}\nabla^2\psi_2 + m V(\rbm{x})\psi_2,\\
\hbar \partial_t\psi_2 &=& \frac{\hbar^2}{2a^2m} \nabla^2\psi_1 - mV(\rbm{x})\psi_1.
\eea
\section{Methods to compute derivatives on a lattice}
\subsection{Finite difference}
\label{sec:fdd}
The discretization of the  first derivative of a  function $f(\rbm{x})$ at lattice site ``$i$'' is
\bea
\pd{f}{x} = \frac{f_{i+1} - f_{i-1}}{2h},
\eea
and the second derivative   discretized to second order is
\bea
\pd{^2f}{x^2} = \frac{f_{i+1} + f_{i-1} - 2f_i}{h^2}.
\eea
We could also discretize second derivatives to fourth order via
\bea
\pd{^2f}{x^2} = \frac{-f_{i+2}+ 16f_{i+1} - 30 f_i + 16f_{i-1} -f_{i-2}}{12h^2}.
\eea
Typically, we implement finite difference derivatives to second order. This is because the finite difference derivatives are used since they are ``cheap and cheerful'': to get more accurate derivatives we move away from finite difference altogether.

The Laplacian can be discretized in a few ways. Let us take the 3D Laplacian as an example. The simplest is to combine the second order discretization of the second derivative:
\bea
\nabla^2f = \frac{f_{i+1,j,k} + f_{i-1,j,k} + f_{i,j+1,k} + f_{i,j-1,k} + f_{i,j,k+1} + f_{i,j,k-1} - 6f_{i,j,k}}{h^2}.
\eea
In \cite{Frolov:2008hy} a set of stencils for the Laplacian are given; the stencils correspond to the coefficients of each term in the discrete Laplacian -- for the one given above, the stencil is $(-6, 1)$. In our 3D code we have implemented the finite difference Laplacian with four different stencils:
\bea
S_1&:& (-6, 1, 0, 0),\\
S_2&:& (4, 1/3, 1/6, 0),\\
S_3&:& (14/3, 2/3, 0, 1/12),\\
S_4&:& (64/15, 7/15, 1/10, 1/30).
\eea
The entries are the coefficients of lattice sites which are (0, 1, 2, 3) lattice links away from the site at which the Laplacian is being computed.



\subsection{Fast Fourier transform}
The method of finite differences for computing derivatives on a lattice is (very) quick, but has rather large errors for noisy data. There are also \textit{spectral methods}, which use  the discrete Fourier transform of the data. These are especially useful for periodic systems. To see how spectral methods work, note that from the (inverse Fourier transform of) a function
\bea
f(x) = \int \dd k \hat{f}(k) e^{\ci kx} =: \mathcal{F}^{-1}(\hat{f})
\eea
one can easily compute the first and second derivatives
\bea
\pd{}{x}f =\mathcal{F}^{-1}(\ci k\hat{f}),\qquad \pd{^2}{x^2}f = \mathcal{F}^{-1}(-k^2\hat{f}).
\eea
We have chose to implement the discrete    Fourier transform (and its inverse) via the library {\tt FFTW3}. We have tested accuracy .vs. time taken to compute the derivatives, we have constructed a simple code which computes the derivative of   sine waves in a box with space step-size {\tt h}, and {\tt imax} grid-points. We compute the time taken to construct  derivative using   finite difference and FFT schemes, and the error on each (computed against   exact analytic expressions for the derivatives).

By way of setup,
\begin{verbatim}
// Space step-size
double h = 0.05;
// Number of grid-points
int imax = 200;
// Function type (just for this testing purpose)
int fn_type = 2;
// How many waves in the box?
double wavn =  6.0;
double omega = wavn * 2.0 * PI / ( h * imax );
double fn(double x){
    if(fn_type == 1) return sin( x * omega );
    if(fn_type == 2) return sin( x * omega ) + sin( x * 2.0 * omega );
}
\end{verbatim}
Here is the output 
\begin{verbatim}
// Space step-size
double h = 0.2;

FT(data) :: 1.86043 milliseconds
iFT(d_data) :: 1.17383 milliseconds
FT(data) :: 0.041698 milliseconds
iFT(dd_data) :: 0.0388 milliseconds
// Errors
Error on FD first derivative: 0.028334
Error on FD second derivative: 0.0266803
Error on FFT first derivative: 1.45685e-14
Error on FFT second derivative: 1.6575e-13
// Compute times
FD first derivative compute time: 0.015488 milliseconds
FD second derivative compute time: 0.005887 milliseconds
FFT first derivative compute time: 3.11555 milliseconds
FFT second derivative compute time: 0.119432 milliseconds
\end{verbatim}
The compute time  isnt particularly interesting (for these small numbers of grid-points): but, the relative error on the finite difference and FFT derivatives is worth noting.



\section{Elliptic PDEs}
Here we outline some methods of numerically solving elliptic partial differential equations. As an example, we will show how to solve the 2D Poisson equation,
\bea
\nabla^2V = -\rho.
\eea
Here, $V = V(\rbm{x})$ is a ``potential'', and $\rho = \rho(\rbm{x})$ a source.
Using the second order finite difference discretization scheme outlined  in section \ref{sec:fdd}, the discrete version of this is
\bea
V_{i+1,j}+V_{i-1,j}-4V_{i,j} + V_{i,j+1}+V_{i,j-1} = -h^2\rho_{i,j}.
\eea
Here we used second order accurate derivative discretization. This can be rearranged to find
\bea
V_{i,j} = \frac{1}{4}\bigg[V_{i+1,j}+V_{i-1,j}+ V_{i,j+1}+V_{i,j-1} + h^2\rho_{i,j}\bigg].
\eea
There is clearly an issue: the value of the potential (which is to be found) relies on knowledge of the potential on its four neighbouring lattice sites. The remedy is to update the potential using (fictitious) time-steps;
\bea
\label{eq:sec:simple-update}
V^{n+1}_{i,j} = \frac{1}{4}\bigg[V^n_{i+1,j}+V^n_{i-1,j}+ V^n_{i,j+1}+V^n_{i,j-1} + h^2\rho_{i,j}\bigg].
\eea
This is Jacobi's iterative method.
As $n$ increments, the values of the potential $V$ converge onto those which solve the Poisson equation. There are clever ways of doing this, and each has different convergence properties.
\subsection{Gauss-Seidel method}
The Jacobi method   (\ref{eq:sec:simple-update}) can be made faster by using the newly updated field values on the RHS,
\bea
V_{i,j}^{n+1} = \frac{1}{4}\bigg[ V_{i+1,j}^n + V^{n+1}_{i-1,j} + V^n_{i,j+1} + V^{n+1}_{i,j-1}+h^2\rho_{i,j} \bigg].
\eea
\subsection{Successive over relaxation}
Another method is to using a different linear combination,
\bea
V_{i,j}^{n+1} = (1-\omega) V^n_{i,j} + \frac{\omega}{4}\bigg[ V_{i+1,j}^n + V^{n+1}_{i-1,j} + V^n_{i,j+1} + V^{n+1}_{i,j-1}+h^2\rho_{i,j} \bigg]
\eea
The parameter $\omega$ is the SoR parameter. Its value determines the convergence of the algorithm:
\begin{itemize}
\item Only convergent if $0<\omega <2$,
\item Faster than Gauss-Seidel if $1 <\omega <2$,
\item Fastest on square lattice if $\omega \sim 2/(1+\pi/L)$, where $L$ is the number of lattice points in each direction.
\end{itemize}
\subsection{Checks against known analytic solutions}
We want to check the convergence properties of the codes against known solutions.
\bea
\rho(x,y) = 2x^3 + 6xy(y-1),\qquad V(x,y) = x^3y(1-y)
\eea
\section{Hyperbolic PDEs}
Here we outline how to solve hyperbolic PDEs; that is, wave equations of the form
\bea
\ddot{\Phi} - \nabla^2\Phi + U'(\Phi) = S(\rbm{x}).
\eea
Here, $S(\rbm{x})$ is some source term (which will be important for the applications we have in mind), and  $U(\Phi)$ is the scalar field potential; typically, $U = \half m^2\Phi^2$ is a mass term. First, we trivially re-write this as
\bea
\ddot{\Phi} = \nabla^2\Phi - U' + S,
\eea
so that nothing on the RHS has time derivatives. We will write everything in 2D to reduce the number of indices needed to write the expressions down: the code is in 3D, and we shall explicitly point out any subtleties associates with going from 2D to 3D. 

We   define an ``equation of motion'' term
\bea
\mathcal{E}^t_{i,j} \defn \nabla^2\Phi^t_{i,j} - U'^t_{i,j} + S^t_{i,j},
\eea
where the Laplacian is discretized as
\bea
\nabla^2\Phi^t_{i,j} = \frac{\Phi^t_{i+1,j} + \Phi^t_{i-1,j} - 2 \Phi^t_{i,j}}{h^2} + \frac{\Phi^t_{i,j+1} + \Phi^t_{i,j-1} - 2 \Phi^t_{i,j}}{h^2}.
\eea
The second time derivative at a given location is discretized to second order as
\bea
\ddot{\Phi} = \frac{\Phi^{t+1}_{i,j} + \Phi^{t-1}_{i,j} - 2 \Phi^t_{i,j}}{h_t^2}.
\eea
Hence,
\bea
\Phi_{i,j}^{t+1} = h_t^2\mathcal{E}^t_{i,j}  - \Phi^{t-1}_{i,j} + 2 \Phi^t_{i,j}.
\eea
This gives a rule to update the value of the field at each location.
\subsection{Tests of the code}
To check the code, we have implemented a few different types of initial conditions  and potentials (this also helps to build intuition). To make sure that the code accesses arrays correctly, we begin by solving the gradient flow equation
\bea
\dot{\Phi} = \nabla^2\Phi - U'(\Phi),
\eea
for two different potentials:
\bea
U_{(1)}(\Phi) = \half \Phi^2,\qquad U_{(2)} (\Phi) = \frac{1}{4}(\Phi^2 - 1)^2.
\eea
For a system endowed with the potential $U_{(1)}$, any homogeneous initial field configuration will evolve towards $\Phi =0$, since those are the values which minimise the potential. Similarly, a system endowed with $U_{(2)}$ with homogeneous initial conditions will evolve towards $\Phi = \pm 1$.

The space- and time-step sizes must be carefully chosen: not all values give numerically stable evolutions. For the free wave equation, $\ddot{\Phi} - \nabla^2\Phi =0$, one typically requires
\bea
h_t < h,
\eea
and for the gradient flow equation $\dot{\Phi} - \nabla^2\Phi =0$ one typically requires
\bea
h_t < h^2.
\eea
\section{Initial conditions for 1D collapse}
For the background cosmology we use an Einstein-de sitter universe with
\begin{equation}
H^2 = \frac{8 \pi}{3} G \rho_0 a^{-3}\,.
\end{equation}
As time coordinate we use superconformal time $\eta$, defined by $a^2 d \eta = dt = (a H)^{-1} da$. We then have $t(a) = a^{3/2}/\sqrt{6 \pi G \rho_0} = 2/3\,a^{3/2}\,H_0^{-1} $ or $\eta(a) = - a^{-1/2}/\sqrt{2\pi G \rho_0/3}= -2  a^{-1/2} H_0^{-1} $. Therefore
\begin{equation}\label{inipsi}
a(\eta) =  \frac{4 }{\eta^{2} H_0^2}\,.
\end{equation}

\subsection{Schr\"odinger}
The Schr\"odinger-Poisson equations read then
\begin{align}
i \tilde{\hbar} \partial_\eta  \psi &= - \frac{\tilde{\hbar}^2}{2 } \psi'' + a^2 \psi V\\
V'' &=  \tfrac{3}{2} H_0^2 a^{-1} (\psi^* \psi -1)\,,
\end{align}
where $'$ denotes a derivative with respect to the comoving spatial coordinate $x$. Nearly cold initial conditions can be implemented by choosing 
\begin{equation}\label{inipsi}
\psi_{\rm{ini}}(x)= \sqrt{n_{\rm d}(a_{\rm{ini}},x)} \exp\left[ i \phi_{\rm d}(a_{\rm{ini}},x)/\tilde \hbar \right]\,,
\end{equation}
at some early time where shell crossings haven't occurred yet. A subscript d refers to quantities that one would use as initial conditions for a dust fluid: $n_{\rm d} = 1 + \delta_{\rm d}$ encodes the density perturbation and $\phi_{\rm d}$ the velocity potential, which will choose to be very small such that their linear perturbation theory expressions can be used. A ``sine wave collapse'', or ``pancake collapse'' can be obtained by choosing
\begin{align} \label{delini}
\delta_{\rm d}(a,x) &= a \cos\left(\frac{\pi x}{L}\right) \,,\\
V_{\rm d}(a,x) &= -  4 \pi G \frac{L^2}{\pi^2} \frac{\rho_0}{a}  \delta_{\rm d}(a,x) \,,\\
\phi_{\rm d}(a,x) &= -\frac{2}{3 H(a)}V_{\rm d}(a,x)
\end{align}
One can choose for the constants: $a_{\rm ini} =0.01$ (initial scale factor), $L=10\,\mathrm{Mpc}$ (2L is the size of the periodic box), $H_0 = H(a=1) = 70\,\mathrm{km s^{-1} Mpc^{-1}}$ (Hubble constant), $\tilde \hbar\equiv \hbar/m = 2\times 10^{-5} c\, \mathrm{Mpc}$ (phase space resolution), where $c$ is the speed of light.
\subsection{Klein-Gordon}
The initial conditions for the Klein-Gordon field $\Phi$ can be chosen to be the same as for $\psi$, since $\Phi \simeq e^{- i t m} \psi(\eta, x) a^{-3/2}$  in the non-relativistic case and the overall phase at the initial time $\eta_{\rm ini}$ shouldn't matter. In the KG case, we also do not need to choose a value for $m$, since it drops out from the KG equation, once we introduce $\tilde \hbar$.
\appendix
\section{Using the code}
\subsection{Klein-Gordon solver}
The code is written in C$^{++}$, and requires {\tt GSL} and {\tt boost} libraries. To check that these are both installed correctly, nagivate to the {\tt KGsolve} root directory, the compiling and running of the code is performed with the following three commands:
\begin{verbatim}
make clean
make
./main
\end{verbatim}
The code should compile without error. The source code is in the directory {\tt src}.

The \codeBlue{GetParams} function reads in the {\tt params.ini} file, then the \codeBlue{SetupGrid} function tells the struct
\begin{verbatim}
GRIDINFO grid;
\end{verbatim}
how many grid-points are in the {\tt i}, {\tt j}, {\tt k}-directions, and what the lattice and time step-sizes are. Immediately after the grid is setup, the field is setup in the function \codeBlue{SetupField}. The  field  is stored as a one-dimensional array, and is part of a struct named {\tt field}. To generate one, 
\begin{verbatim}
FIELDCONTAINER field;
\end{verbatim}
This sets up a number of important entities:
\begin{itemize}
\item {\tt field.vals} --    array which holds all of the values of the field at all locations, for all components of the field (if the field has multiple components). 
\item {\tt field.deriv\_X} --    array which holds the $\hat{X}$-derivative of each component of the field at a given location. Explicitly, there are {\tt deriv\_x, deriv\_y, deriv\_z}.
\item {\tt field.laplacian} --   array holds the Laplacian of each component of the field at a given location.
\item {\tt field.dpot} --   array holds the derivative of the field potential, with respect to a given component of the field, at a given location.
\item {\tt field.eom} --   array holds everything which equals the time derivative of a given component of the field, at a given location.
\end{itemize}
Functions for computing the values of these quantities are found in the file \codeRed{filestruct.h}.

The value of the field at an array location is {\tt field.vals[pos]} (usually, {\tt field->vals[pos]} needs to be typed outside of the \codeRed{main.cpp} file). To access the value of the field corresponding to a given component, at a given time, and position on the grid, one should call the function {\tt ind}. As an example, to get the current value of the c$\qsuprm{}{th}$-component of the field, at the location whose lattice sites are $(i,j,k)$, one calls
\begin{verbatim}
int pos = ind(now,c,i,j,k,grid,field);
field.vals[pos];
\end{verbatim}
The code only stores two time-steps of the field: this is all thats required for second order accurate time derivatives.
A log file is then written with all parameter choices etc. That completes the setup of the code. 

Next is the initial condition setup. The function \codeBlue{InitialConditions} is called which sets {\tt field.vals} at all spatial locations, for the first two time-steps. The parameter {\tt params.inittype} can be used to select how to do the initial conditions. There are three types coded up by default: {\tt inittype = 0} sets the field homogeneous, {\tt inittype = 1} sets the field at random values about the origin, and {\tt inittype = 2} sets the field with a discontinuous kink in the $x$-direction.

After the initial conditions have been set, the function \codeBlue{SolveKG3D} is called which solves the ``Klein-Gordon'' equation. In the function, a struct
\begin{verbatim}
THIST timehistory;
\end{verbatim}
is setup to contain ``time history'' information -- this is usually (spatially) integrated information about the grid at a given time-step. There is a loop which runs untill {\tt params.ntimsteps} is reached. At each time-step, there are loops over all 3 spatial directions. At each location the following sequence is called
\begin{itemize}
\item \codeBlue{field->GetDeriv} -- gets all spatial derivatives of the field
\item \codeBlue{field->Getdpot} -- gets the derivative of the potential w.r.t each component of the field. The type of potential is selected via the parameter {\tt params.pottype}. Currently, {\tt pottype = 0} corresponds to a massive scalar field, and {\tt pottype = 1} to a Higgs potential.
\item \codeBlue{field->GetEoM} -- constructs the RHS of the equation of motion. The type of equation of motion is selected via the parameter {\tt params.eomtype}. Currently, {\tt eomtype = 0} corresponds to $\mathcal{E}_i = \nabla^2\phi_i -  {\partial V}/{\partial\phi_i}$. Here, $\mathcal{E}_i$ is the equation of motion of the $\phi_i$-component of the field.
\item \codeBlue{field->UpdateField} -- updates the value of the field. The type of update rule is selected via the parameter {\tt params.evoltype}. Currently, {\tt evoltype = 0} corresponds to a gradient flow evolution, $\dot{\phi}_i = \mathcal{E}_i$, and {\tt evoltype = 1} corresponds to a second order time derivative evolution, $\ddot{\phi}_i = \mathcal{E}_i$.
\end{itemize}
All of these functions are explicitly implemented in \codeRed{fieldstruct.h}.

When the time-step number is divisible by the parameter {\tt filefreq}, then the field is dumped to file via the function call \codeBlue{WriteFieldData} (which is defined in \codeRed{fieldstruct.h}).

Once these loops are completed, the function \codeBlue{CleanField} deletes all the allocated memory, and the final parts to the logfile are written and printed to screen.


\subsection{Contents of each source code file}
\begin{itemize}
\item \codeRed{main.cpp}
\item \codeRed{setup.cpp} 
\subitem \codeBlue{SetupGrid}
\subitem \codeBlue{SetupField}
\subitem \codeBlue{GetParams}
\subitem \codeBlue{CheckParams}
\subitem \codeBlue{checkdirexists}
\item \codeRed{initialconditions.cpp} 
\subitem \codeBlue{InitialConditions}  -- calls \codeBlue{SetInitialConditions} at each location
\subitem \codeBlue{SetInitialConditions} -- set the initial conditions at a given location
\item \codeRed{kgsolve.cpp} 
\subitem \codeBlue{SolveKG3D}
\item \codeRed{fieldstruct.h} 
\subitem \codeBlue{ind} -- returns array index for field values at a given time, component, location
\subitem \codeBlue{GetDeriv} -- selects which scheme to use for spatial derivatives
\subitem \codeBlue{GetDeriv\_2} -- returns second order accurate finite difference spatial derivatives
\subitem  \codeBlue{GetDeriv\_4} -- returns fourth order accurate finite difference spatial derivatives
\subitem \codeBlue{Getpot} -- returns field potential
\subitem \codeBlue{Getdpot} -- returns derivative of field potential w.r.t each component as array
\subitem \codeBlue{GetEoM} -- returns RHS of equation of motion
\subitem \codeBlue{UpdateField} -- updates field value
\subitem\codeBlue{WriteFieldData} -- dumps field value to file
\subitem \codeBlue{CleanField} -- deletes the allocated memory
\item \codeRed{gridstruct.h}
\subitem \codeBlue{SetTime} -- sets the time-access index accordingly
\subitem \codeBlue{GetPos} -- sets values of {\tt grid.loc\_X}, and calls \codeBlue{GetP} and  \codeBlue{GetM}
\subitem \codeBlue{GetP} -- sets values of {\tt grid.Xp} (e.g. {\tt ip=i+1}), using periodic boundaries 
\subitem \codeBlue{GetM} -- sets values of {\tt grid.Xm} (e.g. {\tt im=i-1}), using periodic boundaries 
\item \codeRed{timehistorystruct.h}
\subitem \codeBlue{SetFieldValDump} -- sets field locations to dump into timehistory file
\subitem \codeBlue{write} -- writes timehistory items
\subitem \codeBlue{CleanUp} -- deletes allocated memory
\end{itemize}

\bibliographystyle{JHEP}
\bibliography{refs}
\end{document}